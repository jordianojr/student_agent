text
**Single Responsibility Principle (SRP)**. Single Responsibility Principle. You can isolate complex construction code from the business logic of the product. The Factory Method separates product construction code from the code that actually uses the product. Therefore it's easier to extend the product construction code independently from the rest of the code.
**Open/Closed Principle (OCP)**. Open/Closed Principle. You can introduce new types of products into the program without breaking existing client code. Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.
**Liskov Substitution Principle (LSP)**. now you can override the factory method in a subclass and change the class of products being created by the method The client treats all the products as abstract Transport. The client knows that all transport objects are supposed to have the deliver method, but exactly how it works isn't important to the client.
**Dependency Inversion Principle (DIP)**. The client code doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract Transport. The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code. The framework (high-level) depends on the abstraction (factory method) rather than concrete classes. The client code treats all the products as abstract Transport.
**Collaboration Between Coders**. There are two coders involved (potentially between vendors or teams), what is the implications of this design? The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.
**Avoiding Tight Coupling**. You avoid tight coupling between the creator and the concrete products. The Factory Method separates product construction code from the code that actually uses the product. You can introduce new types of products into the program without breaking existing client code.
**Reusability Across Teams**. Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with. The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code. Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one. The Factory Method allows subclasses to alter the type of objects that will be created.
**Handling Multiple Coders in Complex Systems**. There are two coders involved (potentially between vendors or teams), what is the implications of this design? Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component? you create a subclass UIWithRoundButtons from a base framework class and override its createButton method. You can introduce new types of products into the program without breaking existing client code.
**SOLID Principles in Practice**. Single Responsibility Principle. You can isolate complex construction code from the business logic of the product. You avoid tight coupling between the creator and the concrete products. Use the Factory Method when you don't know beforehand the exact types and dependencies of the objects your code should work with. You can introduce new types of products into the program without breaking existing client code. The director class completely hides the details of product construction from the client code.
**Single Responsibility Principle**. Single Responsibility Principle: This principle states that a class should only have one responsibility. Furthermore, it should only have one reason to change. This principle states that a class should only have one responsibility. Furthermore, it should only have one reason to change.
**Open-Closed Principle**. Classes should be open for extension but closed for modification. In doing so, we stop ourselves from modifying existing code and causing potential new bugs in an otherwise happy application. To extend the feature of adding a tag to a post message, Left - a new class is extended with a new createPost method. Right – an if else statement is written within the createPost method.
"**Liskov Substitution Principle**. if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program. Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle. Rectangle rect = new Square(); // Let’s say this object is passed to another developer with the impression it’s a rectangle class.
rect.setWidth(5);
rect.setHeight(9);
System.out.println(""The area is "" + rect.getArea());   // confused as expected area is 5*9=45 but the output is 81."
**Interface Segregation Principle**. Interface segregation. It simply means that larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.
**Dependency Inversion Principle**. Dependency inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions. Left – FileLogger object is instantiated within the customer object Right – FileLogger object is injected into the customer object
**Technical Debt**. Technical debt (also known as design debt[1] or code debt, but can be also related to other technical endeavors) is a concept in software development that reflects the implied cost of additional rework caused by choosing an easy (limited) solution now instead of using a better approach that would take longer.[2] *These points are also applicable at the systems level. * Beware of Technical Debts!
**Encapsulation & Gateway Façade**. Example – you have a set of objects that implement a feature. You might want your callers to invoke this feature only through one or few objects in this set to encapsulate the rest of the objects. (encapsulation, gateway façade)
**Singleton Pattern**. Example – you might want your object to be instantiated only once to save memory. (consistency, singleton)
**Extending Behavior with Inheritance**. To extend the post feature with adding a tag to a post message, Left - a new class is extended with a new createPost method Right – an if else statement is written within the createPost method For left, it extend but also modify the behavior that both setHeight and setWidth are the same. Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle.
**Avoiding Code Duplication**. Left – FileLogger object is instantiated within the customer object Right – FileLogger object is injected into the customer object To extend feature of adding a tag post, Left - a new class is extended with a new createPost method Right – an if else statement is written within the createPost method Classes should be open for extension but closed for modification. In doing so, we stop ourselves from modifying existing code and causing potential new bugs in an otherwise happy application. larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them. instead of high-level modules depending on low-level modules, both will depend on abstractions.
**Interface-Based Design**. Interface segregation. It simply means that larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them. To design interfaces for creating new post and reading existing posts features. Caller can create or read posts or both. Left – create an interface with create and another with create and read. Right – create an interface with create and another with read. Example – you have a set of objects that implement a feature. You might want to allow your callers to invoke this feature only through one or few objects in this set to encapsulate the rest of the objects. (encapsulation, gateway façade)
**Modular Design**. Design your components to be modular and reusable so that it is analyzed, modified and tested a class should have one, and only one, reason to change. Depend on abstractions not on concrete implementations. Encapsulation, gateway façade Classes should be open for extension but closed for modification. If class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program. The Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle.
"**Error Handling in Code**. class Customer { void add(Database db) { try { db.add(); } catch (Exception ex) { try { FileWriter fw=new FileWriter(""D:\testout.txt""); fw.write(""Welcome to ITSA.""); fw.close(); } catch(Exception e){ System.out.println(e); } } } } class Customer { private FileLogger logger = new FileLogger(); void add(Database db) { try { db.add(); } catch (Exception ex) { logger.handle(ex.toString()); } } } interface Logger { public void handle(String error); } class FileLogger { void handle(String error) { try { FileWriter fw= new FileWriter(""D:\testout.txt""); fw.write(""Welcome to ITSA.""); fw.close(); } catch(Exception e) { System.out.println(e); } } } To add customer to database and log exception,"
**Decoupling with Dependency Injection**. Dependency inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions. Left – FileLogger object is instantiated within the customer object Right – FileLogger object is injected into the customer object If you need to modify the behaviour, will their code needs to change? (decoupling, interfaces, factory, subclass)
"**Behavioral Consistency**. if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program. Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle. Rectangle rect = new Square(); // Let’s say this object is passed to another developer with the impression it’s a rectangle class. rect.setWidth(5); rect.setHeight(9); System.out.println(""The area is "" + rect.getArea()); // confused as expected area is 5*9=45 but the output is 81."
**Refactoring for Clarity**. Example – you have a set of objects that implement a feature. You might want your callers to invoke this feature only through one or few objects in this set to encapsulate the rest of the objects. (encapsulation, gateway façade) Example - there are other callers that instantiate your classes (do a new) and invoke the methods. If you need to modify the behaviour, will their code needs to change? (decoupling, interfaces, factory, subclass) Example – you might want your object to be instantiated only once to save memory. (consistency, singleton) Testing – A class with one responsibility will have far fewer test cases. Of course, the one exception to the rule is when fixing bugs in existing code.
"**Avoiding Overhead in Inheritance**. Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle. Rectangle rect = new Square(); // Let’s say this object is passed to another developer with the impression it’s a rectangle class. rect.setWidth(5); rect.setHeight(9); System.out.println(""The area is "" + rect.getArea()); // confused as expected area is 5*9=45 but the output is 81."
**Testing and Maintenance**. Testability: ... determine whether those criteria have been met... Analyzability: ... assess the impact on a product or system of an intended change... Modifiability: ... modified without introducing defects or degrading existing product quality... Technical Debts! (also known as design debt...) Testing – A class with one responsibility will have far fewer test cases. Lower coupling – Less functionality in a single class will have fewer dependencies. Dependency Inversion Principle: ... both will depend on abstractions. Left – add method includes adding to database and writing out exception Right – Writing exception is delegated to another object. Single Responsibility Principle: ... a class should only have one responsibility. Open for Extension, Closed for Modification: ... classes should be open for extension but closed for modification. Liskov Substitution Principle: ... replace B with A without disrupting the behavior of our program. Interface Segregation Principle: ... larger interfaces should be split into smaller ones. Dependency Inversion: ... high-level modules depending on low-level modules, both will depend on abstractions.
**Code Example: Dependency Inversion**. Dependency inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions. Left – FileLogger object is instantiated within the customer object Right – FileLogger object is injected into the customer object
"**Practical Implications of Liskov Substitution**. Square does not comply with the behavior of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle. Rectangle rect = new Square(); // Let’s say this object is passed to another developer with the impression it’s a rectangle class. rect.setWidth(5); rect.setHeight(9); System.out.println(""The area is "" + rect.getArea()); // confused as expected area is 5*9=45 but the output is 81."
